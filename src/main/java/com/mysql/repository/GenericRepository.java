package com.mysql.repository;

import com.mysql.config.DataSource;
import com.mysql.converter.jdbc.insert.InsertJdbcConverter;
import com.mysql.converter.jdbc.remove.RemoveJdbcConverter;
import com.mysql.converter.jdbc.update.UpdateJdbcConverter;
import com.mysql.dto.InsertDataDto;
import com.mysql.dto.RemoveDataDto;
import com.mysql.dto.UpdateDataDto;
import com.mysql.exception.CloseException;
import com.mysql.exception.NotFoundException;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

public abstract class GenericRepository<E, I> implements Repository<E, I> {

    private final String tableName;
    private final String fieldId;
    private final DataSource dataSource;
    private final InsertJdbcConverter insertJdbcConverter;
    private final UpdateJdbcConverter updateJdbcConverter;
    private final RemoveJdbcConverter removeJdbcConverter;

    public GenericRepository(
            String tableName,
            String fieldId,
            DataSource dataSource,
            InsertJdbcConverter insertJdbcConverter,
            UpdateJdbcConverter updateJdbcConverter,
            RemoveJdbcConverter removeJdbcConverter) {
        this.tableName = tableName;
        this.fieldId = fieldId;
        this.dataSource = dataSource;
        this.insertJdbcConverter = insertJdbcConverter;
        this.updateJdbcConverter = updateJdbcConverter;
        this.removeJdbcConverter = removeJdbcConverter;
    }

    @Override
    public E add(E entity) {
        return execute(connection -> add(entity, connection));
    }

    protected E add(E entity, Connection connection) {
        PreparedStatement preparedStatement = null;

        try {
            if (Objects.isNull(entity)) {
                throw new IllegalArgumentException("Entity is null");
            }

            Map<String, Object> rowData = mapFrom(entity);
            InsertDataDto insertData = insertJdbcConverter.convert(rowData);

            String addQuery = "insert into " + tableName + "(" + insertData.getFieldsPart() + ")" +
                    " values(" + insertData.getValuesPart() + ")";

            preparedStatement = connection.prepareStatement(addQuery, getAutoGeneratedKeys());

            for (int i = 0; i < insertData.getValues().size(); i++) {
                preparedStatement.setObject(i + 1, insertData.getValues().get(i));
            }

            preparedStatement.executeUpdate();
            populateId(preparedStatement, entity);

            return entity;
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            close(preparedStatement);
        }
    }

    @Override
    public E get(I id) {
        return execute(connection -> get(id, connection));
    }

    protected E get(I id, Connection connection) {
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            String getQuery = "select * from " + tableName + " where " + fieldId + " = ?";
            preparedStatement = connection.prepareStatement(getQuery);
            preparedStatement.setObject(1, id);
            resultSet = preparedStatement.executeQuery();

            if (resultSet.next()) {
                return mapTo(resultSet);
            } else {
                throw new NotFoundException(tableName + " with id " + id + " is not found");
            }
        } catch (SQLException ex) {
            throw new IllegalStateException(ex);
        } finally {
            close(resultSet);
            close(preparedStatement);
        }
    }

    @Override
    public void remove(I id) {
        consume(connection -> remove(id, connection));
    }

    protected void remove(I id, Connection connection) {
        PreparedStatement preparedStatement = null;

        try {
            String removeQuery = "delete from " + tableName + " where " + fieldId + " = ?";
            preparedStatement = connection.prepareStatement(removeQuery);
            preparedStatement.setObject(1, id);
            int rowDeleted = preparedStatement.executeUpdate();
            if (rowDeleted == 0) {
                throw new NotFoundException(tableName + " with id " + id + " is not found");
            }
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        } finally {
            close(preparedStatement);
        }
    }

    @Override
    public E edit(E entity) {
        return execute(connection -> edit(entity, connection));
    }

    protected E edit(E entity, Connection connection) {
        PreparedStatement preparedStatement = null;

        try {
            if (Objects.isNull(entity)) {
                throw new IllegalArgumentException("Entity is null");
            }

            I id = getId(entity);
            Map<String, Object> rowData = mapFrom(entity);
            UpdateDataDto updateDataDto = updateJdbcConverter.convert(rowData);
            String editQuery = "update " + tableName + " set " + updateDataDto.getFieldsPart() + " where " + fieldId + " = ?";
            preparedStatement = connection.prepareStatement(editQuery, getAutoGeneratedKeys());
            preparedStatement.setObject(updateDataDto.getValues().size() + 1, id);

            for (int i = 0; i < updateDataDto.getValues().size(); i++) {
                preparedStatement.setObject(i + 1, updateDataDto.getValues().get(i));
            }

            int rowsEffected = preparedStatement.executeUpdate();

            if (rowsEffected == 0) {
                throw new NotFoundException("Entity with id " + id + " is not found");
            }

            return entity;
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            close(preparedStatement);
        }
    }

    @Override
    public List<E> getAll() {
        return execute(this::getAll);
    }

    protected List<E> getAll(Connection connection) {
        String getAllQuery = "select * from " + tableName;
        try (Statement statement = connection.createStatement();
             ResultSet resultSet = statement.executeQuery(getAllQuery)) {
            List<E> entities = new ArrayList<>();
            while (resultSet.next()) {
                entities.add(mapTo(resultSet));
            }
            return entities;
        } catch (SQLException ex) {
            throw new IllegalStateException(ex);
        }
    }

    @Override
    public void removeAll() {
        consume(this::removeAll);
    }

    protected void removeAll(Connection connection) {
        String removeAllQuery = "delete from " + tableName;

        try (Statement statement = connection.createStatement()) {
            statement.executeUpdate(removeAllQuery);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public List<E> addAll(List<E> entities) {
        return execute(connection -> addAll(entities, connection));
    }

    protected List<E> addAll(List<E> entities, Connection connection) {
        return entities.stream()
                .map(entity -> add(entity, connection))
                .collect(Collectors.toList());
    }

    @Override
    public List<E> editAll(List<E> entities) {
        return execute(connection -> editAll(entities, connection));
    }

    protected List<E> editAll(List<E> entities, Connection connection) {
        return entities.stream()
                .map(entity -> edit(entity, connection))
                .collect(Collectors.toList());
    }

    @Override
    public void removeAll(List<I> ids) {
        consume(connection -> removeAll(ids, connection));
    }

    protected void removeAll(List<I> ids, Connection connection) {
        PreparedStatement preparedStatement = null;

        try {
            for (I id : ids) {
                if (Objects.isNull(id)) {
                    throw new IllegalArgumentException("Input data cannot have null!");
                }
            }

            RemoveDataDto removeDataDto = removeJdbcConverter.convert(ids);

            String removeAllQuery = "delete from " + tableName + " where " + fieldId + " in (" + removeDataDto.getFieldsPart() + ")";
            preparedStatement = connection.prepareStatement(removeAllQuery);

            for (int i = 0; i < ids.size(); i++) {
                preparedStatement.setObject(i + 1, ids.get(i));
            }

            int rowsEffected = preparedStatement.executeUpdate();

            if (rowsEffected == 0) {
                throw new NotFoundException("Entity not found");
            }
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        } finally {
            close(preparedStatement);
        }
    }

    protected abstract E mapTo(ResultSet resultSet) throws SQLException;

    protected abstract Map<String, Object> mapFrom(E entity);

    protected abstract int getAutoGeneratedKeys();

    protected abstract void populateId(Statement statement, E entity);

    protected abstract I getId(E entity);

    protected <K> K execute(Function<Connection, K> func) {
        Connection connection = null;
        try {
            connection = dataSource.connection();
            connection.setAutoCommit(false);
            K result = func.apply(connection);
            connection.commit();
            return result;
        } catch (SQLException ex) {
            rollback(connection);
            throw new IllegalStateException(ex);
        } finally {
            close(connection);
        }
    }

    protected void consume(Consumer<Connection> func) {
        Connection connection = null;
        try {
            connection = dataSource.connection();
            connection.setAutoCommit(false);
            func.accept(connection);
            connection.commit();
        } catch (SQLException ex) {
            rollback(connection);
            throw new IllegalStateException(ex);
        } finally {
            close(connection);
        }
    }

    protected void close(ResultSet resultSet) {
        try {
            if (Objects.nonNull(resultSet)) {
                resultSet.close();
            }
        } catch (SQLException ex) {
            throw new CloseException(ex);
        }
    }

    protected void close(Statement statement) {
        try {
            if (Objects.nonNull(statement)) {
                statement.close();
            }
        } catch (SQLException ex) {
            throw new CloseException(ex);
        }
    }

    protected void close(Connection connection) {
        try {
            if (Objects.nonNull(connection)) {
                connection.close();
            }
        } catch (SQLException ex) {
            throw new CloseException(ex);
        }
    }

    private void rollback(Connection connection) {
        try {
            if (Objects.nonNull(connection)) {
                connection.rollback();
            }
        } catch (SQLException ex) {
            throw new CloseException(ex);
        }
    }

}