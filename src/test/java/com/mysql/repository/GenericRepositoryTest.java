package com.mysql.repository;

import com.mysql.config.DataSource;
import com.mysql.converter.jdbc.insert.InsertJdbcConverter;
import com.mysql.converter.jdbc.remove.RemoveJdbcConverter;
import com.mysql.converter.jdbc.update.UpdateJdbcConverter;
import com.mysql.dto.InsertDataDto;
import com.mysql.dto.RemoveDataDto;
import com.mysql.dto.UpdateDataDto;
import com.mysql.entity.City;
import com.mysql.exception.CloseException;
import com.mysql.exception.NotFoundException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.ArgumentMatchers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

@ExtendWith(MockitoExtension.class)
class GenericRepositoryTest {

    private static final String TABLE_NAME = "city";
    private static final String FIELD_ID = "id";
    private static final String FIELDS_PART = "name = ?, countryCode = ?, population = ?, district = ?";
    private static final String VALUES_PART = "valuesPart";

    @Mock
    private DataSource dataSource;

    @Mock
    private InsertJdbcConverter insertJdbcConverter;

    @Mock
    private UpdateJdbcConverter updateJdbcConverter;

    @Mock
    private RemoveJdbcConverter removeJdbcConverter;

    private GenericRepository<City, Integer> genericRepository;

    @BeforeEach
    void init() {
        genericRepository = Mockito.spy(new GenericRepository<>(
                TABLE_NAME,
                FIELD_ID,
                dataSource,
                insertJdbcConverter,
                updateJdbcConverter,
                removeJdbcConverter) {
            @Override
            protected City mapTo(ResultSet resultSet) throws SQLException {
                return null;
            }

            @Override
            protected Map<String, Object> mapFrom(City entity) {
                return null;
            }

            @Override
            protected int getAutoGeneratedKeys() {
                return 0;
            }

            @Override
            protected void populateId(Statement statement, City entity) {

            }

            @Override
            protected Integer getId(City entity) {
                return null;
            }
        });
    }

    @Test
    void add() {
        // given
        City entity = Mockito.mock(City.class);
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entity)
                .when(genericRepository)
                .execute(ArgumentMatchers.any(Function.class));

        Mockito.doReturn(entity)
                .when(genericRepository)
                .add(entity, connection);

        ArgumentCaptor<Function<Connection, City>> functionArgumentCaptor = ArgumentCaptor.forClass(Function.class);

        //when
        City actualEntity = genericRepository.add(entity);

        //then
        Assertions.assertEquals(entity, actualEntity);

        Mockito.verify(genericRepository).execute(functionArgumentCaptor.capture());
        Function<Connection, City> actualFunc = functionArgumentCaptor.getValue();
        City actualCity = actualFunc.apply(connection);

        Assertions.assertEquals(entity, actualCity);
    }

    @Test
    void add_withConnection() throws SQLException {
        //given
        City entity = Mockito.mock(City.class);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        Map<String, Object> rowData = Map.of();
        List<Object> values = List.of("?,", "?,", "?,", "?");
        String addQuery = "insert into " + TABLE_NAME + "(" + FIELDS_PART + ")" + " values(" + VALUES_PART + ")";
        InsertDataDto insertData = new InsertDataDto(FIELDS_PART, VALUES_PART, values);

        Mockito.doReturn(rowData)
                .when(genericRepository)
                .mapFrom(entity);

        Mockito.doReturn(insertData)
                .when(insertJdbcConverter)
                .convert(rowData);

        Mockito.doReturn(Statement.RETURN_GENERATED_KEYS)
                .when(genericRepository)
                .getAutoGeneratedKeys();

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(addQuery, Statement.RETURN_GENERATED_KEYS);

        Mockito.doNothing()
                .when(genericRepository)
                .populateId(preparedStatement, entity);

        //when
        City actualEntity = genericRepository.add(entity, connection);

        //then
        Assertions.assertEquals(entity, actualEntity);

        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void add_withConnectionThrowRuntimeException() throws SQLException {
        //given
        City entity = Mockito.mock(City.class);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        Map<String, Object> rowData = Map.of();
        List<Object> values = List.of("?,", "?,", "?,", "?");
        String addQuery = "insert into " + TABLE_NAME + "(name,countryCode,population,district)" + " values(" + VALUES_PART + ")";
        InsertDataDto insertData = new InsertDataDto("name,countryCode,population,district", VALUES_PART, values);

        Mockito.doReturn(rowData)
                .when(genericRepository)
                .mapFrom(entity);

        Mockito.doReturn(insertData)
                .when(insertJdbcConverter)
                .convert(rowData);

        Mockito.doReturn(Statement.RETURN_GENERATED_KEYS)
                .when(genericRepository)
                .getAutoGeneratedKeys();

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(addQuery, Statement.RETURN_GENERATED_KEYS);

        Mockito.doThrow(new SQLException())
                .when(preparedStatement)
                .executeUpdate();

        //when
        Assertions.assertThrows(
                RuntimeException.class,
                () -> genericRepository.add(entity, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void add_withConnectionThrowIllegalArgumentException() {
        //when
        Assertions.assertThrows(
                IllegalArgumentException.class,
                () -> genericRepository.add(null, Mockito.mock(Connection.class))
        );

        //then
        Mockito.verify(genericRepository).close((PreparedStatement) null);
    }

    @Test
    void get() {
        //given
        Integer id = 10;
        City entity = Mockito.mock(City.class);
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entity)
                .when(genericRepository)
                .execute(ArgumentMatchers.any(Function.class));

        Mockito.doReturn(entity)
                .when(genericRepository)
                .get(id, connection);

        ArgumentCaptor<Function<Connection, City>> functionArgumentCaptor = ArgumentCaptor.forClass(Function.class);

        //when
        City actualResult = genericRepository.get(id);

        //then
        Assertions.assertEquals(entity, actualResult);

        Mockito.verify(genericRepository).execute(functionArgumentCaptor.capture());
        Function<Connection, City> actualFunc = functionArgumentCaptor.getValue();
        City actualCity = actualFunc.apply(connection);

        Assertions.assertEquals(entity, actualCity);
    }

    @Test
    void get_withConnection() throws SQLException {
        //given
        Integer id = 1;
        String getQuery = "select * from " + TABLE_NAME + " where " + FIELD_ID + " = ?";
        City city = Mockito.mock(City.class);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        ResultSet resultSet = Mockito.mock(ResultSet.class);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(getQuery);

        Mockito.doReturn(resultSet)
                .when(preparedStatement)
                .executeQuery();

        Mockito.doReturn(true)
                .when(resultSet)
                .next();

        Mockito.doReturn(city)
                .when(genericRepository)
                .mapTo(resultSet);

        // when
        City actualCity = genericRepository.get(id, connection);

        //then
        Assertions.assertEquals(city, actualCity);

        Mockito.verify(genericRepository).close(resultSet);
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void get_withConnectionThrowIllegalStateException() throws SQLException {
        //given
        Integer id = 1;
        String getQuery = "select * from " + TABLE_NAME + " where " + FIELD_ID + " = ?";
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        ResultSet resultSet = Mockito.mock(ResultSet.class);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(getQuery);

        Mockito.doReturn(resultSet)
                .when(preparedStatement)
                .executeQuery();

        Mockito.doThrow(new SQLException())
                .when(resultSet)
                .next();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.get(id, connection)
        );

        //then
        Mockito.verify(genericRepository).close(resultSet);
        Mockito.verify(genericRepository).close(preparedStatement);
        Mockito.verify(genericRepository, Mockito.never()).mapTo(resultSet);
    }

    @Test
    void get_withConnectionThrowNotFoundException() throws SQLException {
        //given
        Integer id = 1;
        String getQuery = "select * from " + TABLE_NAME + " where " + FIELD_ID + " = ?";
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        ResultSet resultSet = Mockito.mock(ResultSet.class);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(getQuery);

        Mockito.doReturn(resultSet)
                .when(preparedStatement)
                .executeQuery();

        Mockito.doReturn(false)
                .when(resultSet)
                .next();

        //when
        Assertions.assertThrows(
                NotFoundException.class,
                () -> genericRepository.get(id, connection)
        );

        //then
        Mockito.verify(genericRepository).close(resultSet);
        Mockito.verify(genericRepository).close(preparedStatement);
        Mockito.verify(genericRepository, Mockito.never()).mapTo(resultSet);
    }

    @Test
    void remove() {
        //given
        Integer id = 10;
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doNothing()
                .when(genericRepository)
                .consume(ArgumentMatchers.any(Consumer.class));

        Mockito.doNothing()
                .when(genericRepository)
                .remove(id, connection);

        ArgumentCaptor<Consumer<Connection>> consumerArgumentCaptor = ArgumentCaptor.forClass(Consumer.class);

        //when
        genericRepository.remove(id);

        //then
        Mockito.verify(genericRepository).consume(consumerArgumentCaptor.capture());
        Consumer<Connection> actualConsume = consumerArgumentCaptor.getValue();
        actualConsume.accept(connection);

        Mockito.verify(genericRepository).remove(id, connection);
    }

    @Test
    void remove_withConnection() throws SQLException {
        //given
        Integer id = 1;
        String removeQuery = "delete from " + TABLE_NAME + " where " + FIELD_ID + " = ?";
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(ArgumentMatchers.any());

        Mockito.doReturn(-1)
                .when(preparedStatement)
                .executeUpdate();

        ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);

        //when
        genericRepository.remove(id, connection);

        //then
        Mockito.verify(connection).prepareStatement(captor.capture());
        String actualRemoveQuery = captor.getValue();
        Assertions.assertEquals(removeQuery, actualRemoveQuery);

        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void remove_withConnectionThrowNotFoundException() throws SQLException {
        //given
        Integer id = 1;
        String removeQuery = "delete from " + TABLE_NAME + " where " + FIELD_ID + " = ?";
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(removeQuery);

        Mockito.doReturn(0)
                .when(preparedStatement)
                .executeUpdate();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.remove(id, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void remove_withConnectionThrowIllegalStateException() throws SQLException {
        //given
        Integer id = 1;
        String removeQuery = "delete from " + TABLE_NAME + " where " + FIELD_ID + " = ?";
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(removeQuery);

        Mockito.doThrow(new SQLException())
                .when(preparedStatement)
                .executeUpdate();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.remove(id, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);

    }

    @Test
    void edit() {
        //given
        City entity = Mockito.mock(City.class);
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entity)
                .when(genericRepository)
                .execute(ArgumentMatchers.any(Function.class));

        Mockito.doReturn(entity)
                .when(genericRepository)
                .edit(entity, connection);

        ArgumentCaptor<Function<Connection, City>> functionArgumentCaptor = ArgumentCaptor.forClass(Function.class);

        //when
        City actualResult = genericRepository.edit(entity);

        //then
        Assertions.assertEquals(entity, actualResult);

        Mockito.verify(genericRepository).execute(functionArgumentCaptor.capture());
        Function<Connection, City> actualFunc = functionArgumentCaptor.getValue();
        City actualEntity = actualFunc.apply(connection);

        Assertions.assertEquals(entity, actualEntity);
    }

    @Test
    void edit_withConnection() throws SQLException {
        //given
        Integer id = 1;
        List<Object> values = List.of("?,", "?,", "?,", "?");
        String editQuery = "update " + TABLE_NAME + " set " + FIELDS_PART + " where " + FIELD_ID + " = ?";
        UpdateDataDto updateDataDto = new UpdateDataDto(FIELDS_PART, values);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        City entity = Mockito.mock(City.class);
        Map<String, Object> rowData = Map.of();

        Mockito.doReturn(rowData)
                .when(genericRepository)
                .mapFrom(entity);

        Mockito.doReturn(updateDataDto)
                .when(updateJdbcConverter)
                .convert(rowData);

        Mockito.doReturn(Statement.RETURN_GENERATED_KEYS)
                .when(genericRepository)
                .getAutoGeneratedKeys();

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(editQuery, Statement.RETURN_GENERATED_KEYS);

        Mockito.doReturn(id)
                .when(genericRepository)
                .getId(entity);

        Mockito.doReturn(-1)
                .when(preparedStatement)
                .executeUpdate();

        //when
        City actualEntity = genericRepository.edit(entity, connection);

        //then
        Assertions.assertEquals(entity, actualEntity);

        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void edit_withConnectionThrowIllegalArgumentException() {
        //when
        Assertions.assertThrows(
                IllegalArgumentException.class,
                () -> genericRepository.edit(null, Mockito.mock(Connection.class))
        );

        //then
        Mockito.verify(genericRepository).close((PreparedStatement) null);
    }

    @Test
    void edit_withConnectionThrowNotFoundException() throws SQLException {
        //given
        Integer id = 1;
        List<Object> values = List.of("?,", "?,", "?,", "?");
        String editQuery = "update " + TABLE_NAME + " set " + FIELDS_PART + " where " + FIELD_ID + " = ?";
        UpdateDataDto updateDataDto = new UpdateDataDto(FIELDS_PART, values);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        City entity = Mockito.mock(City.class);
        Map<String, Object> rowData = Map.of();

        Mockito.doReturn(rowData)
                .when(genericRepository)
                .mapFrom(entity);

        Mockito.doReturn(updateDataDto)
                .when(updateJdbcConverter)
                .convert(rowData);

        Mockito.doReturn(Statement.RETURN_GENERATED_KEYS)
                .when(genericRepository)
                .getAutoGeneratedKeys();

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(editQuery, Statement.RETURN_GENERATED_KEYS);

        Mockito.doReturn(id)
                .when(genericRepository)
                .getId(entity);

        //when
        Assertions.assertThrows(
                NotFoundException.class,
                () -> genericRepository.edit(entity, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void edit_withConnectionThrowRuntimeException() throws SQLException {
        //given
        Integer id = 1;
        List<Object> values = List.of("?,", "?,", "?,", "?");
        String editQuery = "update " + TABLE_NAME + " set " + FIELDS_PART + " where " + FIELD_ID + " = ?";
        UpdateDataDto updateDataDto = new UpdateDataDto(FIELDS_PART, values);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        City entity = Mockito.mock(City.class);
        Map<String, Object> rowData = Map.of();

        Mockito.doReturn(rowData)
                .when(genericRepository)
                .mapFrom(entity);

        Mockito.doReturn(updateDataDto)
                .when(updateJdbcConverter)
                .convert(rowData);

        Mockito.doReturn(Statement.RETURN_GENERATED_KEYS)
                .when(genericRepository)
                .getAutoGeneratedKeys();

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(editQuery, Statement.RETURN_GENERATED_KEYS);

        Mockito.doReturn(id)
                .when(genericRepository)
                .getId(entity);

        Mockito.doThrow(new SQLException())
                .when(preparedStatement)
                .executeUpdate();

        //when
        Assertions.assertThrows(
                RuntimeException.class,
                () -> genericRepository.edit(entity, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void getAll() {
        //given
        List<City> entities = List.of();
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entities)
                .when(genericRepository)
                .execute(ArgumentMatchers.any(Function.class));

        Mockito.doReturn(entities)
                .when(genericRepository)
                .getAll(connection);

        ArgumentCaptor<Function<Connection, List<City>>> functionArgumentCaptor = ArgumentCaptor.forClass(Function.class);

        //when
        List<City> actualEntitiesResult = genericRepository.getAll();

        //then
        Assertions.assertEquals(entities, actualEntitiesResult);

        Mockito.verify(genericRepository).execute(functionArgumentCaptor.capture());
        Function<Connection, List<City>> actualFunc = functionArgumentCaptor.getValue();
        List<City> actualEntities = actualFunc.apply(connection);

        Assertions.assertEquals(entities, actualEntities);
    }

    @Test
    void getAll_withConnectionResultSetTrue() throws SQLException {
        //given
        City firstEntity = Mockito.mock(City.class);
        City secondEntity = Mockito.mock(City.class);
        Statement statement = Mockito.mock(Statement.class);
        ResultSet resultSet = Mockito.mock(ResultSet.class);
        Connection connection = Mockito.mock(Connection.class);
        List<City> entities = List.of(firstEntity, secondEntity);
        String getAllQuery = "select * from " + TABLE_NAME;

        Mockito.doReturn(statement)
                .when(connection)
                .createStatement();

        Mockito.doReturn(resultSet)
                .when(statement)
                .executeQuery(getAllQuery);

        Mockito.doReturn(true, true, false)
                .when(resultSet)
                .next();

        Mockito.doReturn(firstEntity, secondEntity)
                .when(genericRepository)
                .mapTo(resultSet);

        //when
        List<City> actualEntities = genericRepository.getAll(connection);

        //then
        Assertions.assertEquals(entities, actualEntities);
    }

    @Test
    void getAll_withConnectionTrowIllegalStateException() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doThrow(new SQLException())
                .when(connection)
                .createStatement();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.getAll(connection)
        );
    }

    @Test
    void removeAll() {
        //given
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doNothing()
                .when(genericRepository)
                .consume(ArgumentMatchers.any(Consumer.class));

        Mockito.doNothing()
                .when(genericRepository)
                .removeAll(connection);

        ArgumentCaptor<Consumer<Connection>> consumerArgumentCaptor = ArgumentCaptor.forClass(Consumer.class);

        //when
        genericRepository.removeAll();

        //then
        Mockito.verify(genericRepository).consume(consumerArgumentCaptor.capture());
        Consumer<Connection> actualConsume = consumerArgumentCaptor.getValue();
        actualConsume.accept(connection);

        Mockito.verify(genericRepository).removeAll(connection);
    }

    @Test
    void removeAll_withConnection() throws SQLException {
        //given
        String removeAllQuery = "delete from " + TABLE_NAME;
        Connection connection = Mockito.mock(Connection.class);
        Statement statement = Mockito.mock(Statement.class);

        Mockito.doReturn(statement)
                .when(connection)
                .createStatement();

        Mockito.doReturn(0)
                .when(statement)
                .executeUpdate(removeAllQuery);

        //when
        genericRepository.removeAll(connection);

        //then
        Mockito.verify(statement).executeUpdate(removeAllQuery);
    }

    @Test
    void removeAll_withConnectionThrowRuntimeException() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doThrow(new SQLException())
                .when(connection)
                .createStatement();

        //when
        Assertions.assertThrows(
                RuntimeException.class,
                () -> genericRepository.removeAll(connection)
        );
    }

    @Test
    void addAll_entities() {
        //given
        List<City> entities = List.of();
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entities)
                .when(genericRepository)
                .execute(ArgumentMatchers.any(Function.class));

        Mockito.doReturn(entities)
                .when(genericRepository)
                .addAll(entities, connection);

        ArgumentCaptor<Function<Connection, List<City>>> funcArgumentCaptor = ArgumentCaptor.forClass(Function.class);

        //when
        List<City> actualEntitiesResult = genericRepository.addAll(entities);

        //then
        Assertions.assertEquals(entities, actualEntitiesResult);

        Mockito.verify(genericRepository).execute(funcArgumentCaptor.capture());
        Function<Connection, List<City>> actualFunc = funcArgumentCaptor.getValue();
        List<City> actualEntities = actualFunc.apply(connection);

        Assertions.assertEquals(entities, actualEntities);
    }

    @Test
    void addAll_entitiesWithConnection() {
        //given
        City entity = Mockito.mock(City.class);
        List<City> entities = List.of(entity);
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entity)
                .when(genericRepository)
                .add(entity, connection);

        //when
        List<City> actualEntities = genericRepository.addAll(entities, connection);

        //then
        Assertions.assertEquals(entities, actualEntities);
    }

    @Test
    void editAll_entities() {
        //given
        List<City> entities = List.of();
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entities)
                .when(genericRepository)
                .execute(ArgumentMatchers.any(Function.class));

        Mockito.doReturn(entities)
                .when(genericRepository)
                .editAll(entities, connection);

        ArgumentCaptor<Function<Connection, List<City>>> functionArgumentCaptor = ArgumentCaptor.forClass(Function.class);

        //when
        List<City> actualEntitiesResult = genericRepository.editAll(entities);

        //then
        Assertions.assertEquals(entities, actualEntitiesResult);

        Mockito.verify(genericRepository).execute(functionArgumentCaptor.capture());
        Function<Connection, List<City>> actualFunc = functionArgumentCaptor.getValue();
        List<City> actualEntities = actualFunc.apply(connection);

        Assertions.assertEquals(entities, actualEntities);
    }

    @Test
    void editAll_entitiesWithConnection() {
        //given
        City entity = Mockito.mock(City.class);
        List<City> entities = List.of(entity);
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doReturn(entity)
                .when(genericRepository)
                .edit(entity, connection);

        //when
        List<City> actualEntities = genericRepository.editAll(entities, connection);

        //then
        Assertions.assertEquals(entities, actualEntities);
    }

    @Test
    void removeAll_entities() {
        //given
        List<Integer> ids = List.of();
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doNothing()
                .when(genericRepository)
                .consume(ArgumentMatchers.any(Consumer.class));

        Mockito.doNothing()
                .when(genericRepository)
                .removeAll(ids, connection);

        ArgumentCaptor<Consumer<Connection>> consumerArgumentCaptor = ArgumentCaptor.forClass(Consumer.class);

        //when
        genericRepository.removeAll(ids);

        //then
        Mockito.verify(genericRepository).consume(consumerArgumentCaptor.capture());
        Consumer<Connection> actualConsume = consumerArgumentCaptor.getValue();
        actualConsume.accept(connection);

        Mockito.verify(genericRepository).removeAll(ids, connection);
    }

    @Test
    void removeAll_entitiesWithConnection() throws SQLException {
        //given
        List<Integer> ids = List.of(1, 2);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        RemoveDataDto removeDataDto = new RemoveDataDto(FIELDS_PART);
        String removeAllQuery = "delete from " + TABLE_NAME + " where " + FIELD_ID + " in (" + FIELDS_PART + ")";

        Mockito.doReturn(removeDataDto)
                .when(removeJdbcConverter)
                .convert(ids);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(removeAllQuery);

        Mockito.doReturn(-1)
                .when(preparedStatement)
                .executeUpdate();

        //when
        genericRepository.removeAll(ids, connection);

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void removeAll_entitiesWithConnectionNullIds() {
        //given
        List<Integer> ids = Arrays.asList(1, null);

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.removeAll(ids, Mockito.mock(Connection.class))
        );

        //then
        Mockito.verify(genericRepository).close((PreparedStatement) null);
    }

    @Test
    void removeAll_entitiesWithConnectionThrowNotFoundException() throws SQLException {
        //given
        List<Integer> ids = List.of(1, 2);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        RemoveDataDto removeDataDto = new RemoveDataDto(FIELDS_PART);
        String removeAllQuery = "delete from " + TABLE_NAME + " where " + FIELD_ID + " in (" + FIELDS_PART + ")";

        Mockito.doReturn(removeDataDto)
                .when(removeJdbcConverter)
                .convert(ids);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(removeAllQuery);

        Mockito.doReturn(0)
                .when(preparedStatement)
                .executeUpdate();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.removeAll(ids, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void removeAll_entitiesWithConnectionThrowIllegalStateException() throws SQLException {
        //given
        List<Integer> ids = List.of(1, 2);
        Connection connection = Mockito.mock(Connection.class);
        PreparedStatement preparedStatement = Mockito.mock(PreparedStatement.class);
        RemoveDataDto removeDataDto = new RemoveDataDto(FIELDS_PART);
        String removeAllQuery = "delete from " + TABLE_NAME + " where " + FIELD_ID + " in (" + FIELDS_PART + ")";

        Mockito.doReturn(removeDataDto)
                .when(removeJdbcConverter)
                .convert(ids);

        Mockito.doReturn(preparedStatement)
                .when(connection)
                .prepareStatement(removeAllQuery);

        Mockito.doThrow(new SQLException())
                .when(preparedStatement)
                .executeUpdate();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.removeAll(ids, connection)
        );

        //then
        Mockito.verify(genericRepository).close(preparedStatement);
    }

    @Test
    void execute() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);
        Function<Connection, City> func = Mockito.mock(Function.class);
        City result = Mockito.mock(City.class);

        Mockito.doReturn(connection)
                .when(dataSource)
                .connection();

        Mockito.doReturn(result)
                .when(func)
                .apply(connection);

        //when
        City actualResult = genericRepository.execute(func);

        //then
        Assertions.assertEquals(result, actualResult);

        Mockito.verify(connection).setAutoCommit(false);
        Mockito.verify(connection).commit();
        Mockito.verify(genericRepository).close(connection);
    }

    @Test
    void execute_throwsSQLExceptionWithoutRollback() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);
        Function<Connection, City> func = Mockito.mock(Function.class);

        Mockito.doThrow(new SQLException())
                .when(dataSource)
                .connection();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.execute(func)
        );

        //then
        Mockito.verify(connection, Mockito.never()).rollback();
    }

    @Test
    void execute_throwsSQLExceptionWithRollback() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);
        Function<Connection, City> func = Mockito.mock(Function.class);

        Mockito.doReturn(connection)
                .when(dataSource)
                .connection();

        Mockito.doThrow(new SQLException())
                .when(connection)
                .setAutoCommit(false);

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.execute(func)
        );

        //then
        Mockito.verify(connection).rollback();
    }

    @Test
    void consume() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);
        Consumer<Connection> func = Mockito.mock(Consumer.class);

        Mockito.doReturn(connection)
                .when(dataSource)
                .connection();

        //when
        genericRepository.consume(func);

        //then
        Mockito.verify(connection).setAutoCommit(false);
        Mockito.verify(func).accept(connection);
        Mockito.verify(connection).commit();
        Mockito.verify(genericRepository).close(connection);
    }

    @Test
    void consume_throwsSQLExceptionWithoutRollback() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);
        Consumer<Connection> func = Mockito.mock(Consumer.class);

        Mockito.doThrow(new SQLException())
                .when(dataSource)
                .connection();

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.consume(func)
        );

        //then
        Mockito.verify(connection, Mockito.never()).rollback();
    }

    @Test
    void consume_throwsSQLExceptionWithRollback() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);
        Consumer<Connection> func = Mockito.mock(Consumer.class);

        Mockito.doReturn(connection)
                .when(dataSource)
                .connection();

        Mockito.doThrow(new SQLException())
                .when(connection)
                .setAutoCommit(false);

        //when
        Assertions.assertThrows(
                IllegalStateException.class,
                () -> genericRepository.consume(func)
        );

        //then
        Mockito.verify(connection).rollback();
    }

    @Test
    void close_resultSet() throws SQLException {
        //given
        ResultSet resultSet = Mockito.mock(ResultSet.class);

        //when
        genericRepository.close(resultSet);

        //then
        Mockito.verify(resultSet).close();
    }

    @Test
    void close_resultSetNull() {
        //when
        Assertions.assertDoesNotThrow(() -> genericRepository.close((ResultSet) null));
    }

    @Test
    void close_resultSetThrowsException() throws SQLException {
        //given
        ResultSet resultSet = Mockito.mock(ResultSet.class);

        Mockito.doThrow(new SQLException())
                .when(resultSet)
                .close();

        //when
        Assertions.assertThrows(
                CloseException.class,
                () -> genericRepository.close(resultSet)
        );
    }

    @Test
    void close_statement() throws SQLException {
        //given
        Statement statement = Mockito.mock(Statement.class);

        //when
        genericRepository.close(statement);

        //then
        Mockito.verify(statement).close();
    }

    @Test
    void close_statementNull() {
        //when
        Assertions.assertDoesNotThrow(() -> genericRepository.close((Statement) null));
    }

    @Test
    void close_statementThrowsException() throws SQLException {
        //given
        Statement statement = Mockito.mock(Statement.class);

        Mockito.doThrow(new SQLException())
                .when(statement)
                .close();

        //when
        Assertions.assertThrows(
                CloseException.class,
                () -> genericRepository.close(statement)
        );
    }

    @Test
    void close_connection() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);

        //when
        genericRepository.close(connection);

        //then
        Mockito.verify(connection).close();
    }

    @Test
    void close_connectionNull() {
        //when
        Assertions.assertDoesNotThrow(() -> genericRepository.close((Connection) null));
    }

    @Test
    void close_connectionThrowsException() throws SQLException {
        //given
        Connection connection = Mockito.mock(Connection.class);

        Mockito.doThrow(new SQLException())
                .when(connection)
                .close();

        //when
        Assertions.assertThrows(
                CloseException.class,
                () -> genericRepository.close(connection)
        );
    }
}